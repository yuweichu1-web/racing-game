<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>æ³•æ‹‰åˆ©è·‘é…·</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden;
      touch-action: none;
    }

    .game-container {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    .score-board {
      display: flex;
      justify-content: space-between;
      width: 400px;
      color: #fff;
      font-size: 14px;
      padding: 5px 10px;
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
    }

    .score-item {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .score-label {
      font-size: 10px;
      opacity: 0.7;
      text-transform: uppercase;
    }

    .score-value {
      font-size: 20px;
      font-weight: bold;
      color: #00d9ff;
    }

    .score-value.high { color: #ffd700; }
    .score-value.lives { color: #ff4757; }
    .score-value.level { color: #2ed573; }

    .hud {
      display: flex;
      gap: 15px;
      width: 400px;
      justify-content: center;
    }

    .powerup-indicator {
      display: flex;
      gap: 5px;
      font-size: 20px;
    }

    .powerup {
      opacity: 0.3;
      transition: opacity 0.3s, transform 0.3s;
    }

    .powerup.active {
      opacity: 1;
      transform: scale(1.2);
    }

    #gameCanvas {
      border: 3px solid #00d9ff;
      border-radius: 8px;
      box-shadow: 0 0 30px rgba(0, 217, 255, 0.3);
      background: linear-gradient(180deg, #1a1a2e 0%, #0a0a15 100%);
    }

    .instructions {
      color: rgba(255,255,255,0.6);
      font-size: 12px;
      text-align: center;
      max-width: 400px;
    }
  </style>
</head>
<body>
  <div class="game-container">
    <div class="score-board">
      <div class="score-item">
        <span class="score-label">å¾—åˆ†</span>
        <span class="score-value" id="scoreDisplay">0</span>
      </div>
      <div class="score-item">
        <span class="score-label">æœ€é«˜åˆ†</span>
        <span class="score-value high" id="highScoreDisplay">0</span>
      </div>
      <div class="score-item">
        <span class="score-label">ç”Ÿå‘½</span>
        <span class="score-value lives" id="livesDisplay">â¤ï¸â¤ï¸â¤ï¸</span>
      </div>
      <div class="score-item">
        <span class="score-label">å…³å¡</span>
        <span class="score-value level" id="levelDisplay">1</span>
      </div>
    </div>
    <div class="hud">
      <div class="powerup-indicator" id="powerupDisplay">
        <span class="powerup" id="rocket" title="ç«ç®­">ğŸš€</span>
        <span class="powerup" id="shell" title="ä¹Œé¾Ÿå£³">ğŸ¢</span>
        <span class="powerup" id="shield" title="ç›¾ç‰Œ">ğŸ›¡ï¸</span>
        <span class="powerup" id="star" title="æ— æ•Œ">â­</span>
      </div>
    </div>
    <canvas id="gameCanvas" width="400" height="600"></canvas>
    <div class="instructions">
      ç”µè„‘: â†â†’ ç§»åŠ¨ | ç©ºæ ¼ å¼€å§‹/æš‚åœ<br>
      æ‰‹æœº: ç‚¹å‡»å·¦/å³ä¾§ç§»åŠ¨ï¼Œä¸­é—´å¼€å§‹/æš‚åœ
    </div>
  </div>

  <script>
    // ==================== é…ç½® ====================
    const CONFIG = {
      CANVAS_WIDTH: 400,
      CANVAS_HEIGHT: 600,
      PLAYER_WIDTH: 40,
      PLAYER_HEIGHT: 70,
      PLAYER_SPEED: 8,
      PLAYER_Y: 480,
      OBSTACLE_WIDTH: 40,
      OBSTACLE_HEIGHT: 40,
      POWERUP_SIZE: 35,
      SHELL_SIZE: 30,
      SHELL_SPEED: 12,
      SPAWN_INTERVAL: 1000,
      POWERUP_INTERVAL: 6000,
      SHELL_DURATION: 5000,
      ROCKET_DURATION: 5000,
      SHIELD_DURATION: 3000,
      STAR_DURATION: 5000,
    };

    // å…³å¡é…ç½®
    const LEVELS = [
      { name: 'èµ·æ­¥', boss: 'scooter', bossHP: 50, speed: 3, targetScore: 100 },
      { name: 'åŸå¸‚ç©¿æ¢­', boss: 'taxi', bossHP: 100, speed: 4, targetScore: 200 },
      { name: 'é«˜é€Ÿç‹‚é£™', boss: 'truck', bossHP: 150, speed: 5, targetScore: 300 },
      { name: 'ç»ˆææŒ‘æˆ˜', boss: 'master', bossHP: 200, speed: 6, targetScore: 400 },
    ];

    // é“å…·ç±»å‹
    const Powerups = {
      ROCKET: 'rocket',
      SHELL: 'shell',
      SHIELD: 'shield',
      STAR: 'star',
    };

    // æ¸¸æˆçŠ¶æ€
    const GameStatus = {
      START: 'start',
      PLAYING: 'playing',
      PAUSED: 'paused',
      GAMEOVER: 'gameover',
      LEVEL_COMPLETE: 'levelcomplete',
      VICTORY: 'victory',
    };

    // ==================== æ¸¸æˆçŠ¶æ€ ====================
    let game = {
      status: GameStatus.START,
      level: 0,  // 0-3 å¯¹åº”å…³å¡1-4
      score: 0,
      highScore: parseInt(localStorage.getItem('ferrariHighScore')) || 0,
      lives: 3,
      levelScore: 0,
      speed: 3,
      lastSpawnTime: 0,
      lastPowerupTime: 0,
      levelStartTime: 0,
    };

    // ç©å®¶çŠ¶æ€
    let player = {
      x: CONFIG.CANVAS_WIDTH / 2 - CONFIG.PLAYER_WIDTH / 2,
      y: CONFIG.PLAYER_Y,
      width: CONFIG.PLAYER_WIDTH,
      height: CONFIG.PLAYER_HEIGHT,
    };

    let playerState = {
      rocket: false,
      rocketEndTime: 0,
      shell: false,
      shellEndTime: 0,
      shield: false,
      shieldEndTime: 0,
      star: false,
      starEndTime: 0,
    };

    // ==================== æ¸¸æˆå¯¹è±¡ ====================
    let obstacles = [];
    let powerups = [];
    let shells = [];
    let boss = null;

    // ==================== æŒ‰é”® ====================
    let keys = { left: false, right: false };

    // ==================== Canvas ====================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // DOM å…ƒç´ 
    const scoreDisplay = document.getElementById('scoreDisplay');
    const highScoreDisplay = document.getElementById('highScoreDisplay');
    const livesDisplay = document.getElementById('livesDisplay');
    const levelDisplay = document.getElementById('levelDisplay');
    const powerupDisplay = {
      rocket: document.getElementById('rocket'),
      shell: document.getElementById('shell'),
      shield: document.getElementById('shield'),
      star: document.getElementById('star'),
    };

    highScoreDisplay.textContent = game.highScore;

    // ==================== é”®ç›˜äº‹ä»¶ ====================
    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft') { keys.left = true; e.preventDefault(); }
      if (e.key === 'ArrowRight') { keys.right = true; e.preventDefault(); }
      if (e.key === ' ') { e.preventDefault(); handleSpaceKey(); }
    });

    document.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowLeft') keys.left = false;
      if (e.key === 'ArrowRight') keys.right = false;
    });

    // ==================== è§¦å±äº‹ä»¶ ====================
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const x = touch.clientX - rect.left;

      if (x < rect.width / 3) {
        keys.left = true; keys.right = false;
      } else if (x > rect.width * 2 / 3) {
        keys.right = true; keys.left = false;
      } else {
        handleSpaceKey();
      }
    });

    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      keys.left = false; keys.right = false;
    });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const x = touch.clientX - rect.left;

      if (x < rect.width / 2) {
        keys.left = true; keys.right = false;
      } else {
        keys.right = true; keys.left = false;
      }
    });

    // ==================== æ¸¸æˆæ§åˆ¶ ====================
    function handleSpaceKey() {
      switch (game.status) {
        case GameStatus.START:
        case GameStatus.LEVEL_COMPLETE:
          startLevel();
          break;
        case GameStatus.PLAYING:
          pauseGame();
          break;
        case GameStatus.PAUSED:
          resumeGame();
          break;
        case GameStatus.GAMEOVER:
        case GameStatus.VICTORY:
          restartGame();
          break;
      }
    }

    function startLevel() {
      const level = LEVELS[game.level];
      game.status = GameStatus.PLAYING;
      game.speed = level.speed;
      game.lastSpawnTime = performance.now();
      game.lastPowerupTime = performance.now();
      game.levelStartTime = performance.now();
      game.levelScore = 0;

      // ç”Ÿæˆ BOSS (å…³å¡2-4)
      if (level.boss) {
        createBoss(level.boss, level.bossHP);
      } else {
        boss = null;
      }

      // æ¸…ç†
      obstacles = [];
      powerups = [];
      shells = [];

      updateDisplay();
    }

    function createBoss(type, hp) {
      boss = {
        type: type,
        x: CONFIG.CANVAS_WIDTH / 2 - 50,
        y: -100,
        width: 100,
        height: 60,
        hp: hp,
        maxHp: hp,
        targetX: CONFIG.CANVAS_WIDTH / 2 - 50,
        moveTimer: 0,
      };
    }

    function pauseGame() { game.status = GameStatus.PAUSED; }
    function resumeGame() { game.status = GameStatus.PLAYING; }

    function restartGame() {
      game.level = 0;
      game.score = 0;
      game.lives = 3;
      playerState = { rocket: false, rocketEndTime: 0, shell: false, shellEndTime: 0, shield: false, shieldEndTime: 0, star: false, starEndTime: 0 };
      player.x = CONFIG.CANVAS_WIDTH / 2 - CONFIG.PLAYER_WIDTH / 2;
      obstacles = [];
      powerups = [];
      shells = [];
      boss = null;
      game.status = GameStatus.START;
      updateDisplay();
    }

    function loseLife() {
      if (playerState.shield) {
        playerState.shield = false;
        return;
      }
      if (playerState.star || playerState.rocket) return;

      game.lives--;
      updateDisplay();

      // çŸ­æš‚æ— æ•Œ
      playerState.shield = true;
      playerState.shieldEndTime = performance.now() + 2000;

      if (game.lives <= 0) {
        gameOver();
      }
    }

    function gameOver() {
      game.status = GameStatus.GAMEOVER;
      if (game.score > game.highScore) {
        game.highScore = game.score;
        localStorage.setItem('ferrariHighScore', game.highScore);
        highScoreDisplay.textContent = game.highScore;
      }
    }

    function levelComplete() {
      game.score += (game.level + 1) * 1000;
      updateDisplay();

      if (game.level >= 3) {
        game.status = GameStatus.VICTORY;
        if (game.score > game.highScore) {
          game.highScore = game.score;
          localStorage.setItem('ferrariHighScore', game.highScore);
          highScoreDisplay.textContent = game.highScore;
        }
      } else {
        game.level++;
        game.status = GameStatus.LEVEL_COMPLETE;
      }
    }

    // ==================== é“å…·ç³»ç»Ÿ ====================
    function spawnPowerup() {
      const types = [Powerups.ROCKET, Powerups.SHELL, Powerups.SHIELD, Powerups.STAR];
      const type = types[Math.floor(Math.random() * types.length)];
      powerups.push({
        type: type,
        x: Math.random() * (CONFIG.CANVAS_WIDTH - CONFIG.POWERUP_SIZE),
        y: -CONFIG.POWERUP_SIZE,
        size: CONFIG.POWERUP_SIZE,
      });
    }

    function collectPowerup(powerup) {
      const now = performance.now();

      switch (powerup.type) {
        case Powerups.ROCKET:
          playerState.rocket = true;
          playerState.rocketEndTime = now + CONFIG.ROCKET_DURATION;
          // æ’é£æ‰€æœ‰éšœç¢ç‰©
          obstacles.forEach(obs => {
            obs.y = CONFIG.CANVAS_HEIGHT + 100;
            game.score += 10;
          });
          break;

        case Powerups.SHELL:
          playerState.shell = true;
          playerState.shellEndTime = now + CONFIG.SHELL_DURATION;
          // å‘å°„ä¹Œé¾Ÿå£³
          shells.push({
            x: player.x + player.width / 2 - CONFIG.SHELL_SIZE / 2,
            y: player.y,
            size: CONFIG.SHELL_SIZE,
            vx: 0,
            vy: -CONFIG.SHELL_SPEED,
          });
          break;

        case Powerups.SHIELD:
          playerState.shield = true;
          playerState.shieldEndTime = now + CONFIG.SHIELD_DURATION;
          break;

        case Powerups.STAR:
          playerState.star = true;
          playerState.starEndTime = now + CONFIG.STAR_DURATION;
          break;
      }

      game.score += 20;
      updateDisplay();
    }

    function updatePowerupState() {
      const now = performance.now();

      if (playerState.rocket && now > playerState.rocketEndTime) {
        playerState.rocket = false;
      }
      if (playerState.shell && now > playerState.shellEndTime) {
        playerState.shell = false;
      }
      if (playerState.shield && now > playerState.shieldEndTime) {
        playerState.shield = false;
      }
      if (playerState.star && now > playerState.starEndTime) {
        playerState.star = false;
      }

      // æ›´æ–° UI
      powerupDisplay.rocket.classList.toggle('active', playerState.rocket);
      powerupDisplay.shell.classList.toggle('active', playerState.shell);
      powerupDisplay.shield.classList.toggle('active', playerState.shield);
      powerupDisplay.star.classList.toggle('active', playerState.star);
    }

    // ==================== BOSS é€»è¾‘ ====================
    function updateBoss() {
      if (!boss) return;

      const now = performance.now();

      // BOSS è¿›å…¥
      if (boss.y < 50) {
        boss.y += 2;
        return;
      }

      // ç§»åŠ¨æ¨¡å¼
      boss.moveTimer++;
      const level = LEVELS[game.level];

      if (boss.type === 'scooter') {
        // å°å¹…åº¦æ‘†åŠ¨
        boss.x = CONFIG.CANVAS_WIDTH / 2 - boss.width / 2 + Math.sin(boss.moveTimer * 0.08) * 60;
      } else if (boss.type === 'taxi') {
        // ä¹‹å­—å½¢ç§»åŠ¨
        boss.x = CONFIG.CANVAS_WIDTH / 2 - boss.width / 2 + Math.sin(boss.moveTimer * 0.05) * 120;
      } else if (boss.type === 'truck') {
        // å˜é“æ‹¦æˆª
        if (boss.moveTimer % 200 < 100) {
          boss.x = 30;
        } else {
          boss.x = CONFIG.CANVAS_WIDTH - boss.width - 30;
        }
      } else if (boss.type === 'master') {
        // è¿½è¸ªç©å®¶
        const targetX = player.x - boss.width / 2 + player.width / 2;
        boss.x += (targetX - boss.x) * 0.03;
      }

      // è¾¹ç•Œ
      boss.x = Math.max(0, Math.min(CONFIG.CANVAS_WIDTH - boss.width, boss.x));

      // ç¢°æ’ç©å®¶
      if (checkCollision(player, boss)) {
        if (playerState.star || playerState.rocket) {
          // BOSS å—ä¼¤
          boss.hp -= playerState.rocket ? 30 : 20;
          game.score += 50;
        } else {
          loseLife();
        }
      }

      // BOSS å‡»è´¥
      if (boss.hp <= 0) {
        boss = null;
        game.score += 500;
        levelComplete();
      }
    }

    // ==================== æ›´æ–°é€»è¾‘ ====================
    function updatePlayer() {
      const speed = playerState.rocket ? CONFIG.PLAYER_SPEED * 2 : CONFIG.PLAYER_SPEED;

      if (keys.left) player.x -= speed;
      if (keys.right) player.x += speed;

      player.x = Math.max(0, Math.min(CONFIG.CANVAS_WIDTH - player.width, player.x));
    }

    function spawnObstacle() {
      obstacles.push({
        x: Math.random() * (CONFIG.CANVAS_WIDTH - CONFIG.OBSTACLE_WIDTH),
        y: -CONFIG.OBSTACLE_HEIGHT,
        width: CONFIG.OBSTACLE_WIDTH,
        height: CONFIG.OBSTACLE_HEIGHT,
        passed: false,
      });
    }

    function updateObstacles() {
      const now = performance.now();

      // ç”Ÿæˆéšœç¢ç‰©
      if (now - game.lastSpawnTime > CONFIG.SPAWN_INTERVAL) {
        spawnObstacle();
        game.lastSpawnTime = now;
      }

      // ç”Ÿæˆé“å…·
      if (now - game.lastPowerupTime > CONFIG.POWERUP_INTERVAL) {
        spawnPowerup();
        game.lastPowerupTime = now;
      }

      // ç§»åŠ¨éšœç¢ç‰©
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const obs = obstacles[i];
        obs.y += game.speed;

        // å¾—åˆ†
        if (!obs.passed && obs.y > player.y + player.height) {
          obs.passed = true;
          game.score += 10;
          game.levelScore += 10;
          updateDisplay();

          // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°ç›®æ ‡åˆ†æ•°è¿‡å…³
          const level = LEVELS[game.level];
          if (game.levelScore >= level.targetScore) {
            if (boss) {
              // è¾¾åˆ°åˆ†æ•°åï¼Œæ¯æ¬¡æ’å‡»ç»™BOSSé€ æˆæ›´å¤šä¼¤å®³
              boss.hp -= 50;
              game.score += 50;
            } else {
              // æ²¡æœ‰BOSSï¼Œç›´æ¥è¿‡å…³
              levelComplete();
            }
          }
        }

        // ç§»é™¤
        if (obs.y > CONFIG.CANVAS_HEIGHT) {
          obstacles.splice(i, 1);
        }

        // ç¢°æ’
        if (checkCollision(player, obs)) {
          if (playerState.star || playerState.rocket) {
            // æ’é£
            obs.y = CONFIG.CANVAS_HEIGHT + 100;
            game.score += 10;
          } else {
            obstacles.splice(i, 1);
            loseLife();
          }
        }
      }

      // ç§»åŠ¨é“å…·
      for (let i = powerups.length - 1; i >= 0; i--) {
        const p = powerups[i];
        p.y += game.speed;

        if (checkCollision(player, {x: p.x, y: p.y, width: p.size, height: p.size})) {
          collectPowerup(p);
          powerups.splice(i, 1);
        } else if (p.y > CONFIG.CANVAS_HEIGHT) {
          powerups.splice(i, 1);
        }
      }

      // ç§»åŠ¨ä¹Œé¾Ÿå£³
      for (let i = shells.length - 1; i >= 0; i--) {
        const s = shells[i];
        s.y += s.vy;

        // æ¸…é™¤éšœç¢ç‰©
        for (let j = obstacles.length - 1; j >= 0; j--) {
          if (checkCollision(s, obstacles[j])) {
            obstacles.splice(j, 1);
            game.score += 10;
          }
        }

        // æ’ BOSS
        if (boss && checkCollision(s, boss)) {
          boss.hp -= 30;
          shells.splice(i, 1);
          game.score += 50;
          continue;
        }

        if (s.y < -50) shells.splice(i, 1);
      }
    }

    function checkCollision(rect1, rect2) {
      return rect1.x < rect2.x + rect2.width &&
             rect1.x + rect1.width > rect2.x &&
             rect1.y < rect2.y + rect2.height &&
             rect1.y + rect1.height > rect2.y;
    }

    function updateDisplay() {
      scoreDisplay.textContent = game.score;
      livesDisplay.textContent = 'â¤ï¸'.repeat(Math.max(0, game.lives));
      levelDisplay.textContent = game.level + 1;
    }

    // ==================== ç»˜åˆ¶ ====================
    function drawRoad() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);

      // è¾¹çº¿
      ctx.strokeStyle = '#00d9ff';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(10, 0); ctx.lineTo(10, CONFIG.CANVAS_HEIGHT);
      ctx.moveTo(CONFIG.CANVAS_WIDTH - 10, 0); ctx.lineTo(CONFIG.CANVAS_WIDTH - 10, CONFIG.CANVAS_HEIGHT);
      ctx.stroke();

      // ä¸­çº¿
      ctx.strokeStyle = 'rgba(0, 217, 255, 0.3)';
      ctx.lineWidth = 2;
      ctx.setLineDash([20, 20]);
      ctx.beginPath();
      ctx.moveTo(CONFIG.CANVAS_WIDTH / 2, 0);
      ctx.lineTo(CONFIG.CANVAS_WIDTH / 2, CONFIG.CANVAS_HEIGHT);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    function drawFerrari() {
      const x = player.x;
      const y = player.y;
      const w = player.width;
      const h = player.height;

      // æ— æ•Œ/ç«ç„°æ•ˆæœ
      if (playerState.star) {
        ctx.beginPath();
        ctx.arc(x + w/2, y + h/2, w, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
        ctx.fill();
      }

      // ç«ç„°å°¾ç„° (ç«ç®­åŠ é€Ÿ)
      if (playerState.rocket) {
        const gradient = ctx.createLinearGradient(x + w/2, y + h, x + w/2, y + h + 40);
        gradient.addColorStop(0, '#ff4757');
        gradient.addColorStop(0.5, '#ffa502');
        gradient.addColorStop(1, 'transparent');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.moveTo(x + w/2 - 10, y + h);
        ctx.lineTo(x + w/2 + 10, y + h);
        ctx.lineTo(x + w/2, y + h + 35 + Math.random() * 10);
        ctx.fill();
      }

      // è½¦èº« - æ³•æ‹‰åˆ©çº¢
      ctx.fillStyle = '#DC143C';
      ctx.beginPath();
      ctx.moveTo(x + w * 0.1, y + h);
      ctx.lineTo(x, y + h * 0.3);
      ctx.lineTo(x + w * 0.2, y);
      ctx.lineTo(x + w * 0.5, y);
      ctx.lineTo(x + w * 0.8, y);
      ctx.lineTo(x + w, y + h * 0.3);
      ctx.lineTo(x + w * 0.9, y + h);
      ctx.closePath();
      ctx.fill();

      // é»‘è‰²è½®å»“
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2;
      ctx.stroke();

      // æŒ¡é£ç»ç’ƒ
      ctx.fillStyle = '#1a1a2e';
      ctx.beginPath();
      ctx.moveTo(x + w * 0.25, y + h * 0.15);
      ctx.lineTo(x + w * 0.35, y + h * 0.4);
      ctx.lineTo(x + w * 0.65, y + h * 0.4);
      ctx.lineTo(x + w * 0.75, y + h * 0.15);
      ctx.closePath();
      ctx.fill();

      // è·ƒé©¬æ ‡å¿— (ç®€åŒ–)
      ctx.fillStyle = '#ffd700';
      ctx.font = 'bold 12px Arial';
      ctx.fillText('ğŸ', x + w * 0.35, y + h * 0.7);

      // å¤§ç¯
      ctx.fillStyle = '#fff';
      ctx.fillRect(x + 3, y + h * 0.35, 8, 5);
      ctx.fillRect(x + w - 11, y + h * 0.35, 8, 5);

      // è½¦è½®
      ctx.fillStyle = '#111';
      ctx.fillRect(x - 4, y + h * 0.25, 5, 15);
      ctx.fillRect(x + w - 1, y + h * 0.25, 5, 15);
      ctx.fillRect(x - 4, y + h * 0.6, 5, 15);
      ctx.fillRect(x + w - 1, y + h * 0.6, 5, 15);

      // ç›¾ç‰Œæ•ˆæœ
      if (playerState.shield) {
        ctx.beginPath();
        ctx.arc(x + w/2, y + h/2, w * 0.8, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(0, 150, 255, 0.6)';
        ctx.lineWidth = 3;
        ctx.stroke();
      }
    }

    function drawObstacles() {
      obstacles.forEach(obs => {
        // æ™®é€šéšœç¢ç‰© - å„ç§é¢œè‰²
        const colors = ['#666', '#888', '#555'];
        ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)];
        ctx.fillRect(obs.x, obs.y, obs.width, obs.height);

        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.strokeRect(obs.x, obs.y, obs.width, obs.height);
      });
    }

    function drawPowerups() {
      powerups.forEach(p => {
        let emoji = 'â“';
        let bgColor = '#fff';

        switch (p.type) {
          case Powerups.ROCKET: emoji = 'ğŸš€'; bgColor = '#ff4757'; break;
          case Powerups.SHELL: emoji = 'ğŸ¢'; bgColor = '#2ed573'; break;
          case Powerups.SHIELD: emoji = 'ğŸ›¡ï¸'; bgColor = '#1e90ff'; break;
          case Powerups.STAR: emoji = 'â­'; bgColor = '#ffd700'; break;
        }

        // èƒŒæ™¯
        ctx.fillStyle = bgColor;
        ctx.beginPath();
        ctx.arc(p.x + p.size/2, p.y + p.size/2, p.size/2, 0, Math.PI * 2);
        ctx.fill();

        // Emoji
        ctx.font = `${p.size * 0.6}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(emoji, p.x + p.size/2, p.y + p.size/2);
      });
    }

    function drawShells() {
      shells.forEach(s => {
        ctx.font = `${s.size}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('ğŸ¢', s.x + s.size/2, s.y + s.size/2);
      });
    }

    function drawBoss() {
      if (!boss) return;

      // BOSS è½¦èº«
      let color = '#ffd700';
      let emoji = 'ğŸš•';
      let name = '';

      if (boss.type === 'scooter') { color = '#4169e1'; emoji = 'ğŸ›µ'; name = 'å¤–å–å°å“¥'; }
      else if (boss.type === 'taxi') { color = '#ffd700'; emoji = 'ğŸš•'; name = 'å‡ºç§Ÿè½¦å¸æœº'; }
      else if (boss.type === 'truck') { color = '#ff4757'; emoji = 'ğŸšš'; name = 'å¡è½¦å¸æœº'; }
      else if (boss.type === 'master') { color = '#1a1a1a'; emoji = 'ğŸï¸'; name = 'èµ›è½¦å¤§å¸ˆ'; }

      // è½¦èº«
      ctx.fillStyle = color;
      ctx.fillRect(boss.x, boss.y, boss.width, boss.height);

      // Emoji
      ctx.font = '30px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(emoji, boss.x + boss.width/2, boss.y + boss.height/2);

      // è¡€æ¡èƒŒæ™¯
      ctx.fillStyle = '#333';
      ctx.fillRect(boss.x, boss.y - 15, boss.width, 10);

      // è¡€æ¡
      const hpPercent = boss.hp / boss.maxHp;
      ctx.fillStyle = hpPercent > 0.5 ? '#2ed573' : hpPercent > 0.25 ? '#ffa502' : '#ff4757';
      ctx.fillRect(boss.x, boss.y - 15, boss.width * hpPercent, 10);

      // BOSS åç§°
      ctx.fillStyle = '#fff';
      ctx.font = '12px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(name, boss.x + boss.width/2, boss.y - 22);
    }

    function drawOverlay(text, subtext) {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
      ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);

      ctx.fillStyle = '#fff';
      ctx.font = 'bold 32px "Segoe UI", sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, CONFIG.CANVAS_WIDTH / 2, CONFIG.CANVAS_HEIGHT / 2 - 20);

      if (subtext) {
        ctx.font = '16px "Segoe UI", sans-serif';
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.fillText(subtext, CONFIG.CANVAS_WIDTH / 2, CONFIG.CANVAS_HEIGHT / 2 + 30);
      }
    }

    function drawLevelInfo() {
      const level = LEVELS[game.level];

      // å…³å¡åç§°
      ctx.fillStyle = '#2ed573';
      ctx.font = 'bold 18px "Segoe UI", sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText(`ç¬¬ ${game.level + 1} å…³: ${level.name}`, 20, 30);

      // è¿›åº¦
      const progress = Math.min(1, game.levelScore / level.targetScore);
      ctx.fillStyle = 'rgba(255,255,255,0.2)';
      ctx.fillRect(20, 40, 150, 8);
      ctx.fillStyle = '#2ed573';
      ctx.fillRect(20, 40, 150 * progress, 8);
    }

    function draw() {
      ctx.clearRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
      drawRoad();

      if (game.status === GameStatus.PLAYING || game.status === GameStatus.PAUSED) {
        drawLevelInfo();
        drawObstacles();
        drawPowerups();
        drawShells();
        drawBoss();
        drawFerrari();

        if (game.status === GameStatus.PAUSED) {
          drawOverlay('æ¸¸æˆæš‚åœ', 'æŒ‰ç©ºæ ¼ç»§ç»­');
        }
      } else if (game.status === GameStatus.START) {
        drawOverlay('æ³•æ‹‰åˆ©è·‘é…·', 'æŒ‰ç©ºæ ¼å¼€å§‹æ¸¸æˆ');
      } else if (game.status === GameStatus.GAMEOVER) {
        drawOverlay('æ¸¸æˆç»“æŸ', `å¾—åˆ†: ${game.score} | æŒ‰ç©ºæ ¼é‡æ–°å¼€å§‹`);
      } else if (game.status === GameStatus.LEVEL_COMPLETE) {
        drawOverlay(`ç¬¬ ${game.level} å…³å®Œæˆ!`, 'æŒ‰ç©ºæ ¼è¿›å…¥ä¸‹ä¸€å…³');
      } else if (game.status === GameStatus.VICTORY) {
        drawOverlay('ğŸ‰ æ­å–œé€šå…³! ğŸ‰', `æœ€ç»ˆå¾—åˆ†: ${game.score} | æŒ‰ç©ºæ ¼é‡æ–°å¼€å§‹`);
      }
    }

    // ==================== æ¸¸æˆå¾ªç¯ ====================
    let lastTime = 0;

    function gameLoop(timestamp) {
      const deltaTime = timestamp - lastTime;
      lastTime = timestamp;

      if (game.status === GameStatus.PLAYING) {
        updatePlayer();
        updateObstacles();
        updatePowerupState();
        updateBoss();
      }

      draw();
      requestAnimationFrame(gameLoop);
    }

    // å¯åŠ¨
    updateDisplay();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
